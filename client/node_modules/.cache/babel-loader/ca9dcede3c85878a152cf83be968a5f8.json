{"ast":null,"code":"import adjust_lon from '../common/adjust_lon';\nimport asinz from '../common/asinz';\nimport { EPSLN } from '../constants/values';\n/*\n  reference:\n    Wolfram Mathworld \"Gnomonic Projection\"\n    http://mathworld.wolfram.com/GnomonicProjection.html\n    Accessed: 12th November 2009\n  */\n\nexport function init() {\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0); // Approximation for projecting points to the horizon (infinity)\n\n  this.infinity_dist = 1000 * this.a;\n  this.rc = 1;\n}\n/* Gnomonic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\n\nexport function forward(p) {\n  var sinphi, cosphi;\n  /* sin and cos value        */\n\n  var dlon;\n  /* delta longitude value      */\n\n  var coslon;\n  /* cos of longitude        */\n\n  var ksp;\n  /* scale factor          */\n\n  var g;\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n\n  dlon = adjust_lon(lon - this.long0);\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n\n  if (g > 0 || Math.abs(g) <= EPSLN) {\n    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;\n  } else {\n    // Point is in the opposing hemisphere and is unprojectable\n    // We still need to return a reasonable point, so we project\n    // to infinity, on a bearing\n    // equivalent to the northern hemisphere equivalent\n    // This is a reasonable approximation for short shapes and lines that\n    // straddle the horizon.\n    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);\n    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\nexport function inverse(p) {\n  var rh;\n  /* Rho */\n\n  var sinc, cosc;\n  var c;\n  var lon, lat;\n  /* Inverse equations\n      -----------------*/\n\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n  p.x /= this.k0;\n  p.y /= this.k0;\n\n  if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {\n    c = Math.atan2(rh, this.rc);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n    lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);\n    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);\n    lon = adjust_lon(this.long0 + lon);\n  } else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\nexport var names = [\"gnom\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"sources":["C:/Users/brand/source/repos/DAS-Server/client/node_modules/proj4/lib/projections/gnom.js"],"names":["adjust_lon","asinz","EPSLN","init","sin_p14","Math","sin","lat0","cos_p14","cos","infinity_dist","a","rc","forward","p","sinphi","cosphi","dlon","coslon","ksp","g","x","y","lon","lat","long0","abs","x0","y0","inverse","rh","sinc","cosc","c","k0","sqrt","atan2","phic0","names"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,sBAAvB;AACA,OAAOC,KAAP,MAAkB,iBAAlB;AACA,SAAQC,KAAR,QAAoB,qBAApB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,IAAT,GAAgB;AAErB;AACF;AACE,OAAKC,OAAL,GAAeC,IAAI,CAACC,GAAL,CAAS,KAAKC,IAAd,CAAf;AACA,OAAKC,OAAL,GAAeH,IAAI,CAACI,GAAL,CAAS,KAAKF,IAAd,CAAf,CALqB,CAMrB;;AACA,OAAKG,aAAL,GAAqB,OAAO,KAAKC,CAAjC;AACA,OAAKC,EAAL,GAAU,CAAV;AACD;AAED;AACA;;AACA,OAAO,SAASC,OAAT,CAAiBC,CAAjB,EAAoB;AACzB,MAAIC,MAAJ,EAAYC,MAAZ;AAAoB;;AACpB,MAAIC,IAAJ;AAAU;;AACV,MAAIC,MAAJ;AAAY;;AACZ,MAAIC,GAAJ;AAAS;;AACT,MAAIC,CAAJ;AACA,MAAIC,CAAJ,EAAOC,CAAP;AACA,MAAIC,GAAG,GAAGT,CAAC,CAACO,CAAZ;AACA,MAAIG,GAAG,GAAGV,CAAC,CAACQ,CAAZ;AACA;AACF;;AACEL,EAAAA,IAAI,GAAGjB,UAAU,CAACuB,GAAG,GAAG,KAAKE,KAAZ,CAAjB;AAEAV,EAAAA,MAAM,GAAGV,IAAI,CAACC,GAAL,CAASkB,GAAT,CAAT;AACAR,EAAAA,MAAM,GAAGX,IAAI,CAACI,GAAL,CAASe,GAAT,CAAT;AAEAN,EAAAA,MAAM,GAAGb,IAAI,CAACI,GAAL,CAASQ,IAAT,CAAT;AACAG,EAAAA,CAAC,GAAG,KAAKhB,OAAL,GAAeW,MAAf,GAAwB,KAAKP,OAAL,GAAeQ,MAAf,GAAwBE,MAApD;AACAC,EAAAA,GAAG,GAAG,CAAN;;AACA,MAAKC,CAAC,GAAG,CAAL,IAAYf,IAAI,CAACqB,GAAL,CAASN,CAAT,KAAelB,KAA/B,EAAuC;AACrCmB,IAAAA,CAAC,GAAG,KAAKM,EAAL,GAAU,KAAKhB,CAAL,GAASQ,GAAT,GAAeH,MAAf,GAAwBX,IAAI,CAACC,GAAL,CAASW,IAAT,CAAxB,GAAyCG,CAAvD;AACAE,IAAAA,CAAC,GAAG,KAAKM,EAAL,GAAU,KAAKjB,CAAL,GAASQ,GAAT,IAAgB,KAAKX,OAAL,GAAeO,MAAf,GAAwB,KAAKX,OAAL,GAAeY,MAAf,GAAwBE,MAAhE,IAA0EE,CAAxF;AACD,GAHD,MAIK;AAEH;AACA;AACA;AACA;AACA;AACA;AAEAC,IAAAA,CAAC,GAAG,KAAKM,EAAL,GAAU,KAAKjB,aAAL,GAAqBM,MAArB,GAA8BX,IAAI,CAACC,GAAL,CAASW,IAAT,CAA5C;AACAK,IAAAA,CAAC,GAAG,KAAKM,EAAL,GAAU,KAAKlB,aAAL,IAAsB,KAAKF,OAAL,GAAeO,MAAf,GAAwB,KAAKX,OAAL,GAAeY,MAAf,GAAwBE,MAAtE,CAAd;AAED;;AACDJ,EAAAA,CAAC,CAACO,CAAF,GAAMA,CAAN;AACAP,EAAAA,CAAC,CAACQ,CAAF,GAAMA,CAAN;AACA,SAAOR,CAAP;AACD;AAED,OAAO,SAASe,OAAT,CAAiBf,CAAjB,EAAoB;AACzB,MAAIgB,EAAJ;AAAQ;;AACR,MAAIC,IAAJ,EAAUC,IAAV;AACA,MAAIC,CAAJ;AACA,MAAIV,GAAJ,EAASC,GAAT;AAEA;AACF;;AACEV,EAAAA,CAAC,CAACO,CAAF,GAAM,CAACP,CAAC,CAACO,CAAF,GAAM,KAAKM,EAAZ,IAAkB,KAAKhB,CAA7B;AACAG,EAAAA,CAAC,CAACQ,CAAF,GAAM,CAACR,CAAC,CAACQ,CAAF,GAAM,KAAKM,EAAZ,IAAkB,KAAKjB,CAA7B;AAEAG,EAAAA,CAAC,CAACO,CAAF,IAAO,KAAKa,EAAZ;AACApB,EAAAA,CAAC,CAACQ,CAAF,IAAO,KAAKY,EAAZ;;AAEA,MAAKJ,EAAE,GAAGzB,IAAI,CAAC8B,IAAL,CAAUrB,CAAC,CAACO,CAAF,GAAMP,CAAC,CAACO,CAAR,GAAYP,CAAC,CAACQ,CAAF,GAAMR,CAAC,CAACQ,CAA9B,CAAV,EAA6C;AAC3CW,IAAAA,CAAC,GAAG5B,IAAI,CAAC+B,KAAL,CAAWN,EAAX,EAAe,KAAKlB,EAApB,CAAJ;AACAmB,IAAAA,IAAI,GAAG1B,IAAI,CAACC,GAAL,CAAS2B,CAAT,CAAP;AACAD,IAAAA,IAAI,GAAG3B,IAAI,CAACI,GAAL,CAASwB,CAAT,CAAP;AAEAT,IAAAA,GAAG,GAAGvB,KAAK,CAAC+B,IAAI,GAAG,KAAK5B,OAAZ,GAAuBU,CAAC,CAACQ,CAAF,GAAMS,IAAN,GAAa,KAAKvB,OAAnB,GAA8BsB,EAArD,CAAX;AACAP,IAAAA,GAAG,GAAGlB,IAAI,CAAC+B,KAAL,CAAWtB,CAAC,CAACO,CAAF,GAAMU,IAAjB,EAAuBD,EAAE,GAAG,KAAKtB,OAAV,GAAoBwB,IAApB,GAA2BlB,CAAC,CAACQ,CAAF,GAAM,KAAKlB,OAAX,GAAqB2B,IAAvE,CAAN;AACAR,IAAAA,GAAG,GAAGvB,UAAU,CAAC,KAAKyB,KAAL,GAAaF,GAAd,CAAhB;AACD,GARD,MASK;AACHC,IAAAA,GAAG,GAAG,KAAKa,KAAX;AACAd,IAAAA,GAAG,GAAG,CAAN;AACD;;AAEDT,EAAAA,CAAC,CAACO,CAAF,GAAME,GAAN;AACAT,EAAAA,CAAC,CAACQ,CAAF,GAAME,GAAN;AACA,SAAOV,CAAP;AACD;AAED,OAAO,IAAIwB,KAAK,GAAG,CAAC,MAAD,CAAZ;AACP,eAAe;AACbnC,EAAAA,IAAI,EAAEA,IADO;AAEbU,EAAAA,OAAO,EAAEA,OAFI;AAGbgB,EAAAA,OAAO,EAAEA,OAHI;AAIbS,EAAAA,KAAK,EAAEA;AAJM,CAAf","sourcesContent":["import adjust_lon from '../common/adjust_lon';\nimport asinz from '../common/asinz';\nimport {EPSLN} from '../constants/values';\n\n/*\n  reference:\n    Wolfram Mathworld \"Gnomonic Projection\"\n    http://mathworld.wolfram.com/GnomonicProjection.html\n    Accessed: 12th November 2009\n  */\nexport function init() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n  // Approximation for projecting points to the horizon (infinity)\n  this.infinity_dist = 1000 * this.a;\n  this.rc = 1;\n}\n\n/* Gnomonic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nexport function forward(p) {\n  var sinphi, cosphi; /* sin and cos value        */\n  var dlon; /* delta longitude value      */\n  var coslon; /* cos of longitude        */\n  var ksp; /* scale factor          */\n  var g;\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  dlon = adjust_lon(lon - this.long0);\n\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if ((g > 0) || (Math.abs(g) <= EPSLN)) {\n    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;\n  }\n  else {\n\n    // Point is in the opposing hemisphere and is unprojectable\n    // We still need to return a reasonable point, so we project\n    // to infinity, on a bearing\n    // equivalent to the northern hemisphere equivalent\n    // This is a reasonable approximation for short shapes and lines that\n    // straddle the horizon.\n\n    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);\n    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var rh; /* Rho */\n  var sinc, cosc;\n  var c;\n  var lon, lat;\n\n  /* Inverse equations\n      -----------------*/\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n\n  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    c = Math.atan2(rh, this.rc);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n\n    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);\n    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);\n    lon = adjust_lon(this.long0 + lon);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"gnom\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n"]},"metadata":{},"sourceType":"module"}
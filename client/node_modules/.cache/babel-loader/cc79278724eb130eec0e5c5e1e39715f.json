{"ast":null,"code":"import { PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT, PJD_NODATUM, R2D, SRS_WGS84_ESQUARED, SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR } from './constants/values';\nimport { geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums } from './datumUtils';\nimport adjust_lon from \"./common/adjust_lon\";\n\nfunction checkParams(type) {\n  return type === PJD_3PARAM || type === PJD_7PARAM;\n}\n\nexport default function (source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  } // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n\n\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  } // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n\n  var source_a = source.a;\n  var source_es = source.es;\n\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  } // Do we need to go through geocentric coordinates?\n\n\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {\n    return point;\n  } // Convert to geocentric coordinates.\n\n\n  point = geodeticToGeocentric(point, source_es, source_a); // Convert between datums\n\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n\n  return point;\n}\nexport function applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log('Grid shift grids not found');\n    return -1;\n  }\n\n  var input = {\n    x: -point.x,\n    y: point.y\n  };\n  var output = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  var onlyMandatoryGrids = false;\n  var attemptedGrids = [];\n\n  for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n\n    onlyMandatoryGrids = grid.mandatory;\n\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log(\"Unable to find mandatory grid '\" + grid.name + \"'\");\n        return -1;\n      }\n\n      continue;\n    }\n\n    var subgrid = grid.grid.subgrids[0]; // skip tables that don't match our point at all\n\n    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n    var minX = subgrid.ll[0] - epsilon;\n    var minY = subgrid.ll[1] - epsilon;\n    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n\n    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {\n      continue;\n    }\n\n    output = applySubgridShift(input, inverse, subgrid);\n\n    if (!isNaN(output.x)) {\n      break;\n    }\n  }\n\n  if (isNaN(output.x)) {\n    console.log(\"Failed to find a grid shift table for location '\" + -input.x * R2D + \" \" + input.y * R2D + \" tried: '\" + attemptedGrids + \"'\");\n    return -1;\n  }\n\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\n\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n\n  if (isNaN(pin.x)) {\n    return val;\n  }\n\n  var tb = {\n    x: pin.x,\n    y: pin.y\n  };\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9,\n        tol = 1e-12;\n    var dif, del;\n\n    do {\n      del = nadInterpolate(t, ct);\n\n      if (isNaN(del.x)) {\n        console.log(\"Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.\");\n        break;\n      }\n\n      dif = {\n        x: tb.x - (del.x + t.x),\n        y: tb.y - (del.y + t.y)\n      };\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n\n    if (i < 0) {\n      console.log(\"Inverse grid shift iterator failed to converge.\");\n      return val;\n    }\n\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n\n  return val;\n}\n\nfunction nadInterpolate(pin, ct) {\n  var t = {\n    x: pin.x / ct.del[0],\n    y: pin.y / ct.del[1]\n  };\n  var indx = {\n    x: Math.floor(t.x),\n    y: Math.floor(t.y)\n  };\n  var frct = {\n    x: t.x - 1.0 * indx.x,\n    y: t.y - 1.0 * indx.y\n  };\n  var val = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  var inx;\n\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n\n  inx = indx.y * ct.lim[0] + indx.x;\n  var f00 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx++;\n  var f10 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx += ct.lim[0];\n  var f11 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx--;\n  var f01 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  var m11 = frct.x * frct.y,\n      m10 = frct.x * (1.0 - frct.y),\n      m00 = (1.0 - frct.x) * (1.0 - frct.y),\n      m01 = (1.0 - frct.x) * frct.y;\n  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;\n  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;\n  return val;\n}","map":{"version":3,"sources":["C:/Users/brand/source/repos/DAS-Server/client/node_modules/proj4/lib/datum_transform.js"],"names":["PJD_3PARAM","PJD_7PARAM","PJD_GRIDSHIFT","PJD_NODATUM","R2D","SRS_WGS84_ESQUARED","SRS_WGS84_SEMIMAJOR","SRS_WGS84_SEMIMINOR","geodeticToGeocentric","geocentricToGeodetic","geocentricToWgs84","geocentricFromWgs84","compareDatums","adjust_lon","checkParams","type","source","dest","point","datum_type","source_a","a","source_es","es","gridShiftCode","applyGridShift","undefined","dest_a","dest_b","b","dest_es","datum_params","destGridShiftResult","inverse","grids","length","console","log","input","x","y","output","Number","NaN","onlyMandatoryGrids","attemptedGrids","i","grid","push","name","isNull","mandatory","subgrid","subgrids","epsilon","Math","abs","del","minX","ll","minY","maxX","lim","maxY","applySubgridShift","isNaN","pin","ct","val","tb","PI","t","nadInterpolate","tol","dif","indx","floor","frct","inx","f00","cvs","f10","f11","f01","m11","m10","m00","m01"],"mappings":"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","sourcesContent":["import {\n  PJD_3PARAM,\n  PJD_7PARAM,\n  PJD_GRIDSHIFT,\n  PJD_NODATUM,\n  R2D,\n  SRS_WGS84_ESQUARED,\n  SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR\n} from './constants/values';\n\nimport {geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums} from './datumUtils';\nimport adjust_lon from \"./common/adjust_lon\";\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\n\nexport default function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n  var source_a = source.a;\n  var source_es = source.es;\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  }\n\n  // Do we need to go through geocentric coordinates?\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source_es, source_a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n\n  return point;\n}\n\nexport function applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log('Grid shift grids not found');\n    return -1;\n  }\n  var input = {x: -point.x, y: point.y};\n  var output = {x: Number.NaN, y: Number.NaN};\n  var onlyMandatoryGrids = false;\n  var attemptedGrids = [];\n  for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n    onlyMandatoryGrids = grid.mandatory;\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log(\"Unable to find mandatory grid '\" + grid.name + \"'\");\n        return -1;\n      }\n      continue;\n    }\n    var subgrid = grid.grid.subgrids[0];\n    // skip tables that don't match our point at all\n    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n    var minX = subgrid.ll[0] - epsilon;\n    var minY = subgrid.ll[1] - epsilon;\n    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {\n      continue;\n    }\n    output = applySubgridShift(input, inverse, subgrid);\n    if (!isNaN(output.x)) {\n      break;\n    }\n  }\n  if (isNaN(output.x)) {\n    console.log(\"Failed to find a grid shift table for location '\"+\n      -input.x * R2D + \" \" + input.y * R2D + \" tried: '\" + attemptedGrids + \"'\");\n    return -1;\n  }\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\n\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = {x: Number.NaN, y: Number.NaN};\n  if (isNaN(pin.x)) { return val; }\n  var tb = {x: pin.x, y: pin.y};\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9, tol = 1e-12;\n    var dif, del;\n    do {\n      del = nadInterpolate(t, ct);\n      if (isNaN(del.x)) {\n        console.log(\"Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.\");\n        break;\n      }\n      dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n    if (i < 0) {\n      console.log(\"Inverse grid shift iterator failed to converge.\");\n      return val;\n    }\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n  return val;\n}\n\nfunction nadInterpolate(pin, ct) {\n  var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};\n  var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};\n  var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};\n  var val= {x: Number.NaN, y: Number.NaN};\n  var inx;\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n  inx = (indx.y * ct.lim[0]) + indx.x;\n  var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx++;\n  var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx += ct.lim[0];\n  var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx--;\n  var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),\n    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;\n  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);\n  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);\n  return val;\n}\n"]},"metadata":{},"sourceType":"module"}
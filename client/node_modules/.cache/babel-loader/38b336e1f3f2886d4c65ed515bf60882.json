{"ast":null,"code":"'use strict';\n\nimport { PJD_3PARAM, PJD_7PARAM, HALF_PI } from './constants/values';\nexport function compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n    // the tolerance for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];\n  } else if (source.datum_type === PJD_7PARAM) {\n    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];\n  } else {\n    return true; // datums are equal\n  }\n} // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\n\nexport function geodeticToGeocentric(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn;\n  /*  Earth radius at location  */\n\n  var Sin_Lat;\n  /*  Math.sin(Latitude)  */\n\n  var Sin2_Lat;\n  /*  Square of Math.sin(Latitude)  */\n\n  var Cos_Lat;\n  /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if (Latitude < -HALF_PI) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return {\n      x: -Infinity,\n      y: -Infinity,\n      z: p.z\n    };\n  } else if (Latitude > HALF_PI) {\n    /* Latitude out of range */\n    return {\n      x: Infinity,\n      y: Infinity,\n      z: p.z\n    };\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= 2 * Math.PI;\n  }\n\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / Math.sqrt(1.0e0 - es * Sin2_Lat);\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: (Rn * (1 - es) + Height) * Sin_Lat\n  };\n} // cs_geodetic_to_geocentric()\n\nexport function geocentricToGeodetic(p, es, a, b) {\n  /* local defintions and variables */\n\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = genau * genau;\n  var maxiter = 30;\n  var P;\n  /* distance between semi-minor axis and location */\n\n  var RR;\n  /* distance between center and location */\n\n  var CT;\n  /* sin of geocentric latitude */\n\n  var ST;\n  /* cos of geocentric latitude */\n\n  var RX;\n  var RK;\n  var RN;\n  /* Earth radius at location */\n\n  var CPHI0;\n  /* cos of start or old geodetic latitude in iterations */\n\n  var SPHI0;\n  /* sin of start or old geodetic latitude in iterations */\n\n  var CPHI;\n  /* cos of searched geodetic latitude */\n\n  var SPHI;\n  /* sin of searched geodetic latitude */\n\n  var SDPHI;\n  /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n\n  var iter;\n  /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n\n  var Longitude;\n  var Latitude;\n  var Height;\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n  /*      special cases for latitude and longitude */\n\n  if (P / a < genau) {\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n\n\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n    /*  ellipsoidal (geodetic) height */\n\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  } while (SDPHI * SDPHI > genau2 && iter < maxiter);\n  /*      ellipsoidal (geodetic) latitude */\n\n\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n} // cs_geocentric_to_geodetic()\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\n\nexport function geocentricToWgs84(p, datum_type, datum_params) {\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2]\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6]; // if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n} // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\n\nexport function geocentricFromWgs84(p, datum_type, datum_params) {\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2]\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF; //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n\n}","map":{"version":3,"sources":["C:/Users/brand/source/repos/das-server/client/node_modules/proj4/lib/datumUtils.js"],"names":["PJD_3PARAM","PJD_7PARAM","HALF_PI","compareDatums","source","dest","datum_type","a","Math","abs","es","datum_params","geodeticToGeocentric","p","Longitude","x","Latitude","y","Height","z","Rn","Sin_Lat","Sin2_Lat","Cos_Lat","Infinity","PI","sin","cos","sqrt","geocentricToGeodetic","b","genau","genau2","maxiter","P","RR","CT","ST","RX","RK","RN","CPHI0","SPHI0","CPHI","SPHI","SDPHI","iter","X","Y","Z","atan2","atan","geocentricToWgs84","Dx_BF","Dy_BF","Dz_BF","Rx_BF","Ry_BF","Rz_BF","M_BF","geocentricFromWgs84","x_tmp","y_tmp","z_tmp"],"mappings":"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","sourcesContent":["'use strict';\nimport {PJD_3PARAM, PJD_7PARAM, HALF_PI} from './constants/values';\nexport function compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n    // the tolerance for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n  } else if (source.datum_type === PJD_7PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n  } else {\n    return true; // datums are equal\n  }\n} // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nexport function geodeticToGeocentric(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if (Latitude < -HALF_PI) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return { x: -Infinity, y: -Infinity, z: p.z };\n  } else if (Latitude > HALF_PI) {\n    /* Latitude out of range */\n    return { x: Infinity, y: Infinity, z: p.z };\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= (2 * Math.PI);\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n  };\n} // cs_geodetic_to_geocentric()\n\nexport function geocentricToGeodetic(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = (genau * genau);\n  var maxiter = 30;\n\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  }\n  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n} // cs_geocentric_to_geodetic()\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nexport function geocentricToWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2],\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n} // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nexport function geocentricFromWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2],\n    };\n\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import adjust_lon from '../common/adjust_lon';\nexport function init() {}\nimport { EPSLN } from '../constants/values';\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\n\nexport function forward(p) {\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n\n  while (true) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n\n  theta /= 2;\n  /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n       this is done here because of precision problems with \"cos(theta)\"\n       --------------------------------------------------------------------------*/\n\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n  p.x = x;\n  p.y = y;\n  return p;\n}\nexport function inverse(p) {\n  var theta;\n  var arg;\n  /* Inverse equations\n      -----------------*/\n\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n  /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));\n\n  if (lon < -Math.PI) {\n    lon = -Math.PI;\n  }\n\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n\n  var lat = Math.asin(arg);\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\nexport var names = [\"Mollweide\", \"moll\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"sources":["C:/Users/brand/source/repos/das-server/client/node_modules/proj4/lib/projections/moll.js"],"names":["adjust_lon","init","EPSLN","forward","p","lon","x","lat","y","delta_lon","long0","theta","con","Math","PI","sin","delta_theta","cos","abs","a","x0","y0","inverse","arg","asin","names"],"mappings":"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","sourcesContent":["import adjust_lon from '../common/adjust_lon';\nexport function init() {}\nimport {EPSLN} from '../constants/values';\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\nexport function forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n  while (true) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n  theta /= 2;\n\n  /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n       this is done here because of precision problems with \"cos(theta)\"\n       --------------------------------------------------------------------------*/\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var theta;\n  var arg;\n\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n\n  /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));\n  if (lon < (-Math.PI)) {\n    lon = -Math.PI;\n  }\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n  var lat = Math.asin(arg);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Mollweide\", \"moll\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n"]},"metadata":{},"sourceType":"module"}
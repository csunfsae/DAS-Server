{"ast":null,"code":"import { HALF_PI, EPSLN, FORTPI } from '../constants/values';\nimport qsfnz from '../common/qsfnz';\nimport adjust_lon from '../common/adjust_lon';\n/*\n  reference\n    \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\nexport var S_POLE = 1;\nexport var N_POLE = 2;\nexport var EQUIT = 3;\nexport var OBLIQ = 4;\n/* Initialize the Lambert Azimuthal Equal Area projection\n  ------------------------------------------------------*/\n\nexport function init() {\n  var t = Math.abs(this.lat0);\n\n  if (Math.abs(t - HALF_PI) < EPSLN) {\n    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;\n  } else if (Math.abs(t) < EPSLN) {\n    this.mode = this.EQUIT;\n  } else {\n    this.mode = this.OBLIQ;\n  }\n\n  if (this.es > 0) {\n    var sinphi;\n    this.qp = qsfnz(this.e, 1);\n    this.mmf = 0.5 / (1 - this.es);\n    this.apa = authset(this.es);\n\n    switch (this.mode) {\n      case this.N_POLE:\n        this.dd = 1;\n        break;\n\n      case this.S_POLE:\n        this.dd = 1;\n        break;\n\n      case this.EQUIT:\n        this.rq = Math.sqrt(0.5 * this.qp);\n        this.dd = 1 / this.rq;\n        this.xmf = 1;\n        this.ymf = 0.5 * this.qp;\n        break;\n\n      case this.OBLIQ:\n        this.rq = Math.sqrt(0.5 * this.qp);\n        sinphi = Math.sin(this.lat0);\n        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;\n        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);\n        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);\n        this.ymf = (this.xmf = this.rq) / this.dd;\n        this.xmf *= this.dd;\n        break;\n    }\n  } else {\n    if (this.mode === this.OBLIQ) {\n      this.sinph0 = Math.sin(this.lat0);\n      this.cosph0 = Math.cos(this.lat0);\n    }\n  }\n}\n/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\n\nexport function forward(p) {\n  /* Forward equations\n      -----------------*/\n  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;\n  var lam = p.x;\n  var phi = p.y;\n  lam = adjust_lon(lam - this.long0);\n\n  if (this.sphere) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    coslam = Math.cos(lam);\n\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n\n      if (y <= EPSLN) {\n        return null;\n      }\n\n      y = Math.sqrt(2 / y);\n      x = y * cosphi * Math.sin(lam);\n      y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        coslam = -coslam;\n      }\n\n      if (Math.abs(phi + this.lat0) < EPSLN) {\n        return null;\n      }\n\n      y = FORTPI - phi * 0.5;\n      y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));\n      x = y * Math.sin(lam);\n      y *= coslam;\n    }\n  } else {\n    sinb = 0;\n    cosb = 0;\n    b = 0;\n    coslam = Math.cos(lam);\n    sinlam = Math.sin(lam);\n    sinphi = Math.sin(phi);\n    q = qsfnz(this.e, sinphi);\n\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinb = q / this.qp;\n      cosb = Math.sqrt(1 - sinb * sinb);\n    }\n\n    switch (this.mode) {\n      case this.OBLIQ:\n        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;\n        break;\n\n      case this.EQUIT:\n        b = 1 + cosb * coslam;\n        break;\n\n      case this.N_POLE:\n        b = HALF_PI + phi;\n        q = this.qp - q;\n        break;\n\n      case this.S_POLE:\n        b = phi - HALF_PI;\n        q = this.qp + q;\n        break;\n    }\n\n    if (Math.abs(b) < EPSLN) {\n      return null;\n    }\n\n    switch (this.mode) {\n      case this.OBLIQ:\n      case this.EQUIT:\n        b = Math.sqrt(2 / b);\n\n        if (this.mode === this.OBLIQ) {\n          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);\n        } else {\n          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;\n        }\n\n        x = this.xmf * b * cosb * sinlam;\n        break;\n\n      case this.N_POLE:\n      case this.S_POLE:\n        if (q >= 0) {\n          x = (b = Math.sqrt(q)) * sinlam;\n          y = coslam * (this.mode === this.S_POLE ? b : -b);\n        } else {\n          x = y = 0;\n        }\n\n        break;\n    }\n  }\n\n  p.x = this.a * x + this.x0;\n  p.y = this.a * y + this.y0;\n  return p;\n}\n/* Inverse equations\n  -----------------*/\n\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var lam, phi, cCe, sCe, q, rho, ab;\n\n  if (this.sphere) {\n    var cosz = 0,\n        rh,\n        sinz = 0;\n    rh = Math.sqrt(x * x + y * y);\n    phi = rh * 0.5;\n\n    if (phi > 1) {\n      return null;\n    }\n\n    phi = 2 * Math.asin(phi);\n\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinz = Math.sin(phi);\n      cosz = Math.cos(phi);\n    }\n\n    switch (this.mode) {\n      case this.EQUIT:\n        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);\n        x *= sinz;\n        y = cosz * rh;\n        break;\n\n      case this.OBLIQ:\n        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);\n        x *= sinz * this.cosph0;\n        y = (cosz - Math.sin(phi) * this.sinph0) * rh;\n        break;\n\n      case this.N_POLE:\n        y = -y;\n        phi = HALF_PI - phi;\n        break;\n\n      case this.S_POLE:\n        phi -= HALF_PI;\n        break;\n    }\n\n    lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);\n  } else {\n    ab = 0;\n\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      x /= this.dd;\n      y *= this.dd;\n      rho = Math.sqrt(x * x + y * y);\n\n      if (rho < EPSLN) {\n        p.x = this.long0;\n        p.y = this.lat0;\n        return p;\n      }\n\n      sCe = 2 * Math.asin(0.5 * rho / this.rq);\n      cCe = Math.cos(sCe);\n      x *= sCe = Math.sin(sCe);\n\n      if (this.mode === this.OBLIQ) {\n        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;\n        q = this.qp * ab;\n        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;\n      } else {\n        ab = y * sCe / rho;\n        q = this.qp * ab;\n        y = rho * cCe;\n      }\n    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        y = -y;\n      }\n\n      q = x * x + y * y;\n\n      if (!q) {\n        p.x = this.long0;\n        p.y = this.lat0;\n        return p;\n      }\n\n      ab = 1 - q / this.qp;\n\n      if (this.mode === this.S_POLE) {\n        ab = -ab;\n      }\n    }\n\n    lam = Math.atan2(x, y);\n    phi = authlat(Math.asin(ab), this.apa);\n  }\n\n  p.x = adjust_lon(this.long0 + lam);\n  p.y = phi;\n  return p;\n}\n/* determine latitude from authalic latitude */\n\nvar P00 = 0.33333333333333333333;\nvar P01 = 0.17222222222222222222;\nvar P02 = 0.10257936507936507936;\nvar P10 = 0.06388888888888888888;\nvar P11 = 0.06640211640211640211;\nvar P20 = 0.01641501294219154443;\n\nfunction authset(es) {\n  var t;\n  var APA = [];\n  APA[0] = es * P00;\n  t = es * es;\n  APA[0] += t * P01;\n  APA[1] = t * P10;\n  t *= es;\n  APA[0] += t * P02;\n  APA[1] += t * P11;\n  APA[2] = t * P20;\n  return APA;\n}\n\nfunction authlat(beta, APA) {\n  var t = beta + beta;\n  return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);\n}\n\nexport var names = [\"Lambert Azimuthal Equal Area\", \"Lambert_Azimuthal_Equal_Area\", \"laea\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  S_POLE: S_POLE,\n  N_POLE: N_POLE,\n  EQUIT: EQUIT,\n  OBLIQ: OBLIQ\n};","map":{"version":3,"sources":["C:/Users/brand/source/repos/DAS-Server/client/node_modules/proj4/lib/projections/laea.js"],"names":["HALF_PI","EPSLN","FORTPI","qsfnz","adjust_lon","S_POLE","N_POLE","EQUIT","OBLIQ","init","t","Math","abs","lat0","mode","es","sinphi","qp","e","mmf","apa","authset","dd","rq","sqrt","xmf","ymf","sin","sinb1","cosb1","cos","sinph0","cosph0","forward","p","x","y","coslam","sinlam","q","sinb","cosb","b","cosphi","lam","phi","long0","sphere","a","x0","y0","inverse","cCe","sCe","rho","ab","cosz","rh","sinz","asin","atan2","authlat","P00","P01","P02","P10","P11","P20","APA","beta","names"],"mappings":"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","sourcesContent":["\nimport {HALF_PI, EPSLN, FORTPI} from '../constants/values';\n\nimport qsfnz from '../common/qsfnz';\nimport adjust_lon from '../common/adjust_lon';\n\n/*\n  reference\n    \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\nexport var S_POLE = 1;\n\nexport var N_POLE = 2;\nexport var EQUIT = 3;\nexport var OBLIQ = 4;\n\n/* Initialize the Lambert Azimuthal Equal Area projection\n  ------------------------------------------------------*/\nexport function init() {\n  var t = Math.abs(this.lat0);\n  if (Math.abs(t - HALF_PI) < EPSLN) {\n    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;\n  }\n  else if (Math.abs(t) < EPSLN) {\n    this.mode = this.EQUIT;\n  }\n  else {\n    this.mode = this.OBLIQ;\n  }\n  if (this.es > 0) {\n    var sinphi;\n\n    this.qp = qsfnz(this.e, 1);\n    this.mmf = 0.5 / (1 - this.es);\n    this.apa = authset(this.es);\n    switch (this.mode) {\n    case this.N_POLE:\n      this.dd = 1;\n      break;\n    case this.S_POLE:\n      this.dd = 1;\n      break;\n    case this.EQUIT:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      this.dd = 1 / this.rq;\n      this.xmf = 1;\n      this.ymf = 0.5 * this.qp;\n      break;\n    case this.OBLIQ:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      sinphi = Math.sin(this.lat0);\n      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;\n      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);\n      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);\n      this.ymf = (this.xmf = this.rq) / this.dd;\n      this.xmf *= this.dd;\n      break;\n    }\n  }\n  else {\n    if (this.mode === this.OBLIQ) {\n      this.sinph0 = Math.sin(this.lat0);\n      this.cosph0 = Math.cos(this.lat0);\n    }\n  }\n}\n\n/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nexport function forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;\n  var lam = p.x;\n  var phi = p.y;\n\n  lam = adjust_lon(lam - this.long0);\n  if (this.sphere) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    coslam = Math.cos(lam);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n      if (y <= EPSLN) {\n        return null;\n      }\n      y = Math.sqrt(2 / y);\n      x = y * cosphi * Math.sin(lam);\n      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        coslam = -coslam;\n      }\n      if (Math.abs(phi + this.lat0) < EPSLN) {\n        return null;\n      }\n      y = FORTPI - phi * 0.5;\n      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));\n      x = y * Math.sin(lam);\n      y *= coslam;\n    }\n  }\n  else {\n    sinb = 0;\n    cosb = 0;\n    b = 0;\n    coslam = Math.cos(lam);\n    sinlam = Math.sin(lam);\n    sinphi = Math.sin(phi);\n    q = qsfnz(this.e, sinphi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinb = q / this.qp;\n      cosb = Math.sqrt(1 - sinb * sinb);\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;\n      break;\n    case this.EQUIT:\n      b = 1 + cosb * coslam;\n      break;\n    case this.N_POLE:\n      b = HALF_PI + phi;\n      q = this.qp - q;\n      break;\n    case this.S_POLE:\n      b = phi - HALF_PI;\n      q = this.qp + q;\n      break;\n    }\n    if (Math.abs(b) < EPSLN) {\n      return null;\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n    case this.EQUIT:\n      b = Math.sqrt(2 / b);\n      if (this.mode === this.OBLIQ) {\n        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);\n      }\n      else {\n        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;\n      }\n      x = this.xmf * b * cosb * sinlam;\n      break;\n    case this.N_POLE:\n    case this.S_POLE:\n      if (q >= 0) {\n        x = (b = Math.sqrt(q)) * sinlam;\n        y = coslam * ((this.mode === this.S_POLE) ? b : -b);\n      }\n      else {\n        x = y = 0;\n      }\n      break;\n    }\n  }\n\n  p.x = this.a * x + this.x0;\n  p.y = this.a * y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var lam, phi, cCe, sCe, q, rho, ab;\n  if (this.sphere) {\n    var cosz = 0,\n      rh, sinz = 0;\n\n    rh = Math.sqrt(x * x + y * y);\n    phi = rh * 0.5;\n    if (phi > 1) {\n      return null;\n    }\n    phi = 2 * Math.asin(phi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinz = Math.sin(phi);\n      cosz = Math.cos(phi);\n    }\n    switch (this.mode) {\n    case this.EQUIT:\n      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);\n      x *= sinz;\n      y = cosz * rh;\n      break;\n    case this.OBLIQ:\n      phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);\n      x *= sinz * this.cosph0;\n      y = (cosz - Math.sin(phi) * this.sinph0) * rh;\n      break;\n    case this.N_POLE:\n      y = -y;\n      phi = HALF_PI - phi;\n      break;\n    case this.S_POLE:\n      phi -= HALF_PI;\n      break;\n    }\n    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);\n  }\n  else {\n    ab = 0;\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      x /= this.dd;\n      y *= this.dd;\n      rho = Math.sqrt(x * x + y * y);\n      if (rho < EPSLN) {\n        p.x = this.long0;\n        p.y = this.lat0;\n        return p;\n      }\n      sCe = 2 * Math.asin(0.5 * rho / this.rq);\n      cCe = Math.cos(sCe);\n      x *= (sCe = Math.sin(sCe));\n      if (this.mode === this.OBLIQ) {\n        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;\n        q = this.qp * ab;\n        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;\n      }\n      else {\n        ab = y * sCe / rho;\n        q = this.qp * ab;\n        y = rho * cCe;\n      }\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        y = -y;\n      }\n      q = (x * x + y * y);\n      if (!q) {\n        p.x = this.long0;\n        p.y = this.lat0;\n        return p;\n      }\n      ab = 1 - q / this.qp;\n      if (this.mode === this.S_POLE) {\n        ab = -ab;\n      }\n    }\n    lam = Math.atan2(x, y);\n    phi = authlat(Math.asin(ab), this.apa);\n  }\n\n  p.x = adjust_lon(this.long0 + lam);\n  p.y = phi;\n  return p;\n}\n\n/* determine latitude from authalic latitude */\nvar P00 = 0.33333333333333333333;\n\nvar P01 = 0.17222222222222222222;\nvar P02 = 0.10257936507936507936;\nvar P10 = 0.06388888888888888888;\nvar P11 = 0.06640211640211640211;\nvar P20 = 0.01641501294219154443;\n\nfunction authset(es) {\n  var t;\n  var APA = [];\n  APA[0] = es * P00;\n  t = es * es;\n  APA[0] += t * P01;\n  APA[1] = t * P10;\n  t *= es;\n  APA[0] += t * P02;\n  APA[1] += t * P11;\n  APA[2] = t * P20;\n  return APA;\n}\n\nfunction authlat(beta, APA) {\n  var t = beta + beta;\n  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));\n}\n\nexport var names = [\"Lambert Azimuthal Equal Area\", \"Lambert_Azimuthal_Equal_Area\", \"laea\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  S_POLE: S_POLE,\n  N_POLE: N_POLE,\n  EQUIT: EQUIT,\n  OBLIQ: OBLIQ\n};\n"]},"metadata":{},"sourceType":"module"}
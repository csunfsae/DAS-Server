{"ast":null,"code":"export var PJD_3PARAM = 1;\nexport var PJD_7PARAM = 2;\nexport var PJD_GRIDSHIFT = 3;\nexport var PJD_WGS84 = 4; // WGS84 or equivalent\n\nexport var PJD_NODATUM = 5; // WGS84 or equivalent\n\nexport var SRS_WGS84_SEMIMAJOR = 6378137.0; // only used in grid shift transforms\n\nexport var SRS_WGS84_SEMIMINOR = 6356752.314; // only used in grid shift transforms\n\nexport var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms\n\nexport var SEC_TO_RAD = 4.84813681109535993589914102357e-6;\nexport var HALF_PI = Math.PI / 2; // ellipoid pj_set_ell.c\n\nexport var SIXTH = 0.1666666666666666667;\n/* 1/6 */\n\nexport var RA4 = 0.04722222222222222222;\n/* 17/360 */\n\nexport var RA6 = 0.02215608465608465608;\nexport var EPSLN = 1.0e-10; // you'd think you could use Number.EPSILON above but that makes\n// Mollweide get into an infinate loop.\n\nexport var D2R = 0.01745329251994329577;\nexport var R2D = 57.29577951308232088;\nexport var FORTPI = Math.PI / 4;\nexport var TWO_PI = Math.PI * 2; // SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don't get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\n\nexport var SPI = 3.14159265359;","map":{"version":3,"sources":["C:/Users/brand/source/repos/DAS-Server/client/node_modules/proj4/lib/constants/values.js"],"names":["PJD_3PARAM","PJD_7PARAM","PJD_GRIDSHIFT","PJD_WGS84","PJD_NODATUM","SRS_WGS84_SEMIMAJOR","SRS_WGS84_SEMIMINOR","SRS_WGS84_ESQUARED","SEC_TO_RAD","HALF_PI","Math","PI","SIXTH","RA4","RA6","EPSLN","D2R","R2D","FORTPI","TWO_PI","SPI"],"mappings":"AAAA,OAAO,IAAIA,UAAU,GAAG,CAAjB;AACP,OAAO,IAAIC,UAAU,GAAG,CAAjB;AACP,OAAO,IAAIC,aAAa,GAAG,CAApB;AACP,OAAO,IAAIC,SAAS,GAAG,CAAhB,C,CAAmB;;AAC1B,OAAO,IAAIC,WAAW,GAAG,CAAlB,C,CAAqB;;AAC5B,OAAO,IAAIC,mBAAmB,GAAG,SAA1B,C,CAAsC;;AAC7C,OAAO,IAAIC,mBAAmB,GAAG,WAA1B,C,CAAwC;;AAC/C,OAAO,IAAIC,kBAAkB,GAAG,qBAAzB,C,CAAgD;;AACvD,OAAO,IAAIC,UAAU,GAAG,kCAAjB;AACP,OAAO,IAAIC,OAAO,GAAGC,IAAI,CAACC,EAAL,GAAQ,CAAtB,C,CACP;;AACA,OAAO,IAAIC,KAAK,GAAG,qBAAZ;AACP;;AACA,OAAO,IAAIC,GAAG,GAAG,sBAAV;AACP;;AACA,OAAO,IAAIC,GAAG,GAAG,sBAAV;AACP,OAAO,IAAIC,KAAK,GAAG,OAAZ,C,CACP;AACA;;AAEA,OAAO,IAAIC,GAAG,GAAG,sBAAV;AACP,OAAO,IAAIC,GAAG,GAAG,oBAAV;AACP,OAAO,IAAIC,MAAM,GAAGR,IAAI,CAACC,EAAL,GAAQ,CAArB;AACP,OAAO,IAAIQ,MAAM,GAAGT,IAAI,CAACC,EAAL,GAAU,CAAvB,C,CACP;AACA;AACA;AACA;;AACA,OAAO,IAAIS,GAAG,GAAG,aAAV","sourcesContent":["export var PJD_3PARAM = 1;\nexport var PJD_7PARAM = 2;\nexport var PJD_GRIDSHIFT = 3;\nexport var PJD_WGS84 = 4; // WGS84 or equivalent\nexport var PJD_NODATUM = 5; // WGS84 or equivalent\nexport var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms\nexport var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms\nexport var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms\nexport var SEC_TO_RAD = 4.84813681109535993589914102357e-6;\nexport var HALF_PI = Math.PI/2;\n// ellipoid pj_set_ell.c\nexport var SIXTH = 0.1666666666666666667;\n/* 1/6 */\nexport var RA4 = 0.04722222222222222222;\n/* 17/360 */\nexport var RA6 = 0.02215608465608465608;\nexport var EPSLN = 1.0e-10;\n// you'd think you could use Number.EPSILON above but that makes\n// Mollweide get into an infinate loop.\n\nexport var D2R = 0.01745329251994329577;\nexport var R2D = 57.29577951308232088;\nexport var FORTPI = Math.PI/4;\nexport var TWO_PI = Math.PI * 2;\n// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don't get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\nexport var SPI = 3.14159265359;\n"]},"metadata":{},"sourceType":"module"}
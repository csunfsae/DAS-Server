{"ast":null,"code":"// QSC projection rewritten from the original PROJ4\n// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\nimport { EPSLN, TWO_PI, SPI, HALF_PI, FORTPI } from '../constants/values';\n/* constants */\n\nvar FACE_ENUM = {\n  FRONT: 1,\n  RIGHT: 2,\n  BACK: 3,\n  LEFT: 4,\n  TOP: 5,\n  BOTTOM: 6\n};\nvar AREA_ENUM = {\n  AREA_0: 1,\n  AREA_1: 2,\n  AREA_2: 3,\n  AREA_3: 4\n};\nexport function init() {\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n  /* Determine the cube face from the center of projection. */\n\n  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= FORTPI) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n  /* Fill in useful values for the ellipsoid <-> sphere shift\n   * described in [LK12]. */\n\n\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n} // QSC forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\n\nexport function forward(p) {\n  var xy = {\n    x: 0,\n    y: 0\n  };\n  var lat, lon;\n  var theta, phi;\n  var t, mu;\n  /* nu; */\n\n  var area = {\n    value: 0\n  }; // move lon according to projection's lon\n\n  p.x -= this.long0;\n  /* Convert the geodetic latitude to a geocentric latitude.\n   * This corresponds to the shift from the ellipsoid to the sphere\n   * described in [LK12]. */\n\n  if (this.es !== 0) {\n    //if (P->es != 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n  } else {\n    lat = p.y;\n  }\n  /* Convert the input lat, lon into theta, phi as used by QSC.\n   * This depends on the cube face and the area on it.\n   * For the top and bottom face, we can compute theta and phi\n   * directly from phi, lam. For the other faces, we must use\n   * unit sphere cartesian coordinates as an intermediate step. */\n\n\n  lon = p.x; //lon = lp.lam;\n\n  if (this.face === FACE_ENUM.TOP) {\n    phi = HALF_PI - lat;\n\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - HALF_PI;\n    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = lon > 0.0 ? lon - SPI : lon + SPI;\n    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = HALF_PI + lat;\n\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + HALF_PI;\n    } else if (lon < FORTPI && lon >= -FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon > 0.0 ? -lon + SPI : -lon - SPI;\n    }\n  } else {\n    var q, r, s;\n    var sinlat, coslat;\n    var sinlon, coslon;\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n    }\n\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q = coslat * coslon;\n    r = coslat * sinlon;\n    s = sinlat;\n\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q);\n      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r);\n      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q);\n      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r);\n      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n    } else {\n      /* Impossible */\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n  /* Compute mu and nu for the area of definition.\n   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n\n\n  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n  /* Apply the result to the real area. */\n\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += HALF_PI;\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += SPI;\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * SPI;\n  }\n  /* Now compute x, y from mu and nu */\n\n\n  xy.x = t * Math.cos(mu);\n  xy.y = t * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n  p.x = xy.x;\n  p.y = xy.y;\n  return p;\n} // QSC inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\n\nexport function inverse(p) {\n  var lp = {\n    lam: 0,\n    phi: 0\n  };\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t;\n  var area = {\n    value: 0\n  };\n  /* de-offset */\n\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n  /* Convert the input x, y to the mu and nu angles as used by QSC.\n   * This depends on the area of the cube face. */\n\n  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n  mu = Math.atan2(p.y, p.x);\n\n  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= HALF_PI;\n  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = mu < 0.0 ? mu + SPI : mu - SPI;\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += HALF_PI;\n  }\n  /* Compute phi and theta for the area of definition.\n   * The inverse projection is not described in the original paper, but some\n   * good hints can be found here (as of 2011-12-14):\n   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n   * (search for \"Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>\") */\n\n\n  t = SPI / 12 * Math.tan(mu);\n  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > +1) {\n    cosphi = +1;\n  }\n  /* Apply the result to the real area on the cube face.\n   * For the top and bottom face, we can compute phi and lam directly.\n   * For the other faces, we must use unit sphere cartesian coordinates\n   * as an intermediate step. */\n\n\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = HALF_PI - phi;\n\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = theta < 0.0 ? theta + SPI : theta - SPI;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - HALF_PI;\n    } else\n      /* area.value == AREA_ENUM.AREA_3 */\n      {\n        lp.lam = theta;\n      }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - HALF_PI;\n\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - HALF_PI;\n    } else\n      /* area.value == AREA_ENUM.AREA_3 */\n      {\n        lp.lam = theta < 0.0 ? -theta - SPI : -theta + SPI;\n      }\n  } else {\n    /* Compute phi and lam via cartesian unit sphere coordinates. */\n    var q, r, s;\n    q = cosphi;\n    t = q * q;\n\n    if (t >= 1) {\n      s = 0;\n    } else {\n      s = Math.sqrt(1 - t) * Math.sin(theta);\n    }\n\n    t += s * s;\n\n    if (t >= 1) {\n      r = 0;\n    } else {\n      r = Math.sqrt(1 - t);\n    }\n    /* Rotate q,r,s into the correct area. */\n\n\n    if (area.value === AREA_ENUM.AREA_1) {\n      t = r;\n      r = -s;\n      s = t;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r = -r;\n      s = -s;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t = r;\n      r = s;\n      s = -t;\n    }\n    /* Rotate q,r,s into the correct cube face. */\n\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      t = q;\n      q = -r;\n      r = t;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q = -q;\n      r = -r;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t = q;\n      q = r;\n      r = -t;\n    }\n    /* Now compute phi and lam from the unit sphere coordinates. */\n\n\n    lp.phi = Math.acos(-s) - HALF_PI;\n    lp.lam = Math.atan2(r, q);\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n    }\n  }\n  /* Apply the shift from the sphere to the ellipsoid as described\n   * in [LK12]. */\n\n\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = lp.phi < 0 ? 1 : 0;\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n\n  lp.lam += this.long0;\n  p.x = lp.lam;\n  p.y = lp.phi;\n  return p;\n}\n/* Helper function for forward projection: compute the theta angle\n * and determine the area number. */\n\nfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n  var theta;\n\n  if (phi < EPSLN) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0.0;\n  } else {\n    theta = Math.atan2(y, x);\n\n    if (Math.abs(theta) <= FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= HALF_PI;\n    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = theta >= 0.0 ? theta - SPI : theta + SPI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += HALF_PI;\n    }\n  }\n\n  return theta;\n}\n/* Helper function: shift the longitude. */\n\n\nfunction qsc_shift_lon_origin(lon, offset) {\n  var slon = lon + offset;\n\n  if (slon < -SPI) {\n    slon += TWO_PI;\n  } else if (slon > +SPI) {\n    slon -= TWO_PI;\n  }\n\n  return slon;\n}\n\nexport var names = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"sources":["C:/Users/brand/source/repos/das-server/client/node_modules/proj4/lib/projections/qsc.js"],"names":["EPSLN","TWO_PI","SPI","HALF_PI","FORTPI","FACE_ENUM","FRONT","RIGHT","BACK","LEFT","TOP","BOTTOM","AREA_ENUM","AREA_0","AREA_1","AREA_2","AREA_3","init","x0","y0","lat0","long0","lat_ts","title","face","Math","abs","es","one_minus_f","a","b","one_minus_f_squared","forward","p","xy","x","y","lat","lon","theta","phi","t","mu","area","value","atan","tan","q","r","s","sinlat","coslat","sinlon","coslon","qsc_shift_lon_origin","sin","cos","acos","qsc_fwd_equat_face_theta","sqrt","inverse","lp","lam","nu","cosmu","tannu","tantheta","cosphi","atan2","invert_sign","tanphi","xa","offset","slon","names"],"mappings":"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","sourcesContent":["// QSC projection rewritten from the original PROJ4\n// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\n\nimport {EPSLN, TWO_PI, SPI, HALF_PI, FORTPI} from '../constants/values';\n\n/* constants */\nvar FACE_ENUM = {\n    FRONT: 1,\n    RIGHT: 2,\n    BACK: 3,\n    LEFT: 4,\n    TOP: 5,\n    BOTTOM: 6\n};\n\nvar AREA_ENUM = {\n    AREA_0: 1,\n    AREA_1: 2,\n    AREA_2: 3,\n    AREA_3: 4\n};\n\nexport function init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n\n  /* Determine the cube face from the center of projection. */\n  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= FORTPI) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n\n  /* Fill in useful values for the ellipsoid <-> sphere shift\n   * described in [LK12]. */\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n}\n\n// QSC forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n  var xy = {x: 0, y: 0};\n  var lat, lon;\n  var theta, phi;\n  var t, mu;\n  /* nu; */\n  var area = {value: 0};\n\n  // move lon according to projection's lon\n  p.x -= this.long0;\n\n  /* Convert the geodetic latitude to a geocentric latitude.\n   * This corresponds to the shift from the ellipsoid to the sphere\n   * described in [LK12]. */\n  if (this.es !== 0) {//if (P->es != 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n  } else {\n    lat = p.y;\n  }\n\n  /* Convert the input lat, lon into theta, phi as used by QSC.\n   * This depends on the cube face and the area on it.\n   * For the top and bottom face, we can compute theta and phi\n   * directly from phi, lam. For the other faces, we must use\n   * unit sphere cartesian coordinates as an intermediate step. */\n  lon = p.x; //lon = lp.lam;\n  if (this.face === FACE_ENUM.TOP) {\n    phi = HALF_PI - lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - HALF_PI;\n    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = (lon > 0.0 ? lon - SPI : lon + SPI);\n    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = HALF_PI + lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + HALF_PI;\n    } else if (lon < FORTPI && lon >= -FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);\n    }\n  } else {\n    var q, r, s;\n    var sinlat, coslat;\n    var sinlon, coslon;\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n    }\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q = coslat * coslon;\n    r = coslat * sinlon;\n    s = sinlat;\n\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q);\n      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r);\n      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q);\n      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r);\n      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n    } else {\n      /* Impossible */\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n\n  /* Compute mu and nu for the area of definition.\n   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n\n  /* Apply the result to the real area. */\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += HALF_PI;\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += SPI;\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * SPI;\n  }\n\n  /* Now compute x, y from mu and nu */\n  xy.x = t * Math.cos(mu);\n  xy.y = t * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n\n  p.x = xy.x;\n  p.y = xy.y;\n  return p;\n}\n\n// QSC inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n  var lp = {lam: 0, phi: 0};\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t;\n  var area = {value: 0};\n\n  /* de-offset */\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  /* Convert the input x, y to the mu and nu angles as used by QSC.\n   * This depends on the area of the cube face. */\n  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n  mu = Math.atan2(p.y, p.x);\n  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= HALF_PI;\n  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = (mu < 0.0 ? mu + SPI : mu - SPI);\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += HALF_PI;\n  }\n\n  /* Compute phi and theta for the area of definition.\n   * The inverse projection is not described in the original paper, but some\n   * good hints can be found here (as of 2011-12-14):\n   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n   * (search for \"Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>\") */\n  t = (SPI / 12) * Math.tan(mu);\n  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > +1) {\n    cosphi = +1;\n  }\n\n  /* Apply the result to the real area on the cube face.\n   * For the top and bottom face, we can compute phi and lam directly.\n   * For the other faces, we must use unit sphere cartesian coordinates\n   * as an intermediate step. */\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = HALF_PI - phi;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = theta;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - HALF_PI;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);\n    }\n  } else {\n    /* Compute phi and lam via cartesian unit sphere coordinates. */\n    var q, r, s;\n    q = cosphi;\n    t = q * q;\n    if (t >= 1) {\n      s = 0;\n    } else {\n      s = Math.sqrt(1 - t) * Math.sin(theta);\n    }\n    t += s * s;\n    if (t >= 1) {\n      r = 0;\n    } else {\n      r = Math.sqrt(1 - t);\n    }\n    /* Rotate q,r,s into the correct area. */\n    if (area.value === AREA_ENUM.AREA_1) {\n      t = r;\n      r = -s;\n      s = t;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r = -r;\n      s = -s;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t = r;\n      r = s;\n      s = -t;\n    }\n    /* Rotate q,r,s into the correct cube face. */\n    if (this.face === FACE_ENUM.RIGHT) {\n      t = q;\n      q = -r;\n      r = t;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q = -q;\n      r = -r;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t = q;\n      q = r;\n      r = -t;\n    }\n    /* Now compute phi and lam from the unit sphere coordinates. */\n    lp.phi = Math.acos(-s) - HALF_PI;\n    lp.lam = Math.atan2(r, q);\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n    }\n  }\n\n  /* Apply the shift from the sphere to the ellipsoid as described\n   * in [LK12]. */\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = (lp.phi < 0 ? 1 : 0);\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n\n  lp.lam += this.long0;\n  p.x = lp.lam;\n  p.y = lp.phi;\n  return p;\n}\n\n/* Helper function for forward projection: compute the theta angle\n * and determine the area number. */\nfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n  var theta;\n  if (phi < EPSLN) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0.0;\n  } else {\n    theta = Math.atan2(y, x);\n    if (Math.abs(theta) <= FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= HALF_PI;\n    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += HALF_PI;\n    }\n  }\n  return theta;\n}\n\n/* Helper function: shift the longitude. */\nfunction qsc_shift_lon_origin(lon, offset) {\n  var slon = lon + offset;\n  if (slon < -SPI) {\n    slon += TWO_PI;\n  } else if (slon > +SPI) {\n    slon -= TWO_PI;\n  }\n  return slon;\n}\n\nexport var names = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { D2R, R2D, PJD_3PARAM, PJD_7PARAM } from './constants/values';\nimport datum_transform from './datum_transform';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nimport checkSanity from './checkSanity';\n\nfunction checkNotWGS(source, dest) {\n  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84';\n}\n\nexport default function transform(source, dest, point, enforceAxis) {\n  var wgs84;\n\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n\n  checkSanity(point); // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point, enforceAxis);\n    source = wgs84;\n  } // DGR, 2010/11/12\n\n\n  if (enforceAxis && source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  } // Transform source points to long/lat, if they aren't already.\n\n\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n\n    point = source.inverse(point); // Convert Cartesian to longlat\n\n    if (!point) {\n      return;\n    }\n  } // Adjust for the prime meridian if necessary\n\n\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  } // Convert datums if needed, and if possible.\n\n\n  point = datum_transform(source.datum, dest.datum, point);\n\n  if (!point) {\n    return;\n  } // Adjust for the prime meridian if necessary\n\n\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else {\n    // else project\n    point = dest.forward(point);\n\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  } // DGR, 2010/11/12\n\n\n  if (enforceAxis && dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n}","map":{"version":3,"sources":["C:/Users/brand/source/repos/das-server/client/node_modules/proj4/lib/transform.js"],"names":["D2R","R2D","PJD_3PARAM","PJD_7PARAM","datum_transform","adjust_axis","proj","toPoint","checkSanity","checkNotWGS","source","dest","datum","datum_type","datumCode","transform","point","enforceAxis","wgs84","Array","isArray","axis","projName","x","y","z","to_meter","inverse","from_greenwich","forward"],"mappings":"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","sourcesContent":["import {D2R, R2D, PJD_3PARAM, PJD_7PARAM} from './constants/values';\nimport datum_transform from './datum_transform';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nimport checkSanity from './checkSanity';\n\nfunction checkNotWGS(source, dest) {\n  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');\n}\n\nexport default function transform(source, dest, point, enforceAxis) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n  checkSanity(point);\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point, enforceAxis);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (enforceAxis && source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n    point = source.inverse(point); // Convert Cartesian to longlat\n    if (!point) {\n      return;\n    }\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n  if (!point) {\n    return;\n  }\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else { // else project\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (enforceAxis && dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\nimport pj_enfn from '../common/pj_enfn';\nvar MAX_ITER = 20;\nimport pj_mlfn from '../common/pj_mlfn';\nimport pj_inv_mlfn from '../common/pj_inv_mlfn';\nimport { EPSLN, HALF_PI } from '../constants/values';\nimport asinz from '../common/asinz';\nexport function init() {\n  /* Place parameters in static storage for common use\n    -------------------------------------------------*/\n  if (!this.sphere) {\n    this.en = pj_enfn(this.es);\n  } else {\n    this.n = 1;\n    this.m = 0;\n    this.es = 0;\n    this.C_y = Math.sqrt((this.m + 1) / this.n);\n    this.C_x = this.C_y / (this.m + 1);\n  }\n}\n/* Sinusoidal forward equations--mapping lat,long to x,y\n  -----------------------------------------------------*/\n\nexport function forward(p) {\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n    -----------------*/\n\n  lon = adjust_lon(lon - this.long0);\n\n  if (this.sphere) {\n    if (!this.m) {\n      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;\n    } else {\n      var k = this.n * Math.sin(lat);\n\n      for (var i = MAX_ITER; i; --i) {\n        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));\n        lat -= V;\n\n        if (Math.abs(V) < EPSLN) {\n          break;\n        }\n      }\n    }\n\n    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));\n    y = this.a * this.C_y * lat;\n  } else {\n    var s = Math.sin(lat);\n    var c = Math.cos(lat);\n    y = this.a * pj_mlfn(lat, s, c, this.en);\n    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\nexport function inverse(p) {\n  var lat, temp, lon, s;\n  p.x -= this.x0;\n  lon = p.x / this.a;\n  p.y -= this.y0;\n  lat = p.y / this.a;\n\n  if (this.sphere) {\n    lat /= this.C_y;\n    lon = lon / (this.C_x * (this.m + Math.cos(lat)));\n\n    if (this.m) {\n      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);\n    } else if (this.n !== 1) {\n      lat = asinz(Math.sin(lat) / this.n);\n    }\n\n    lon = adjust_lon(lon + this.long0);\n    lat = adjust_lat(lat);\n  } else {\n    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);\n    s = Math.abs(lat);\n\n    if (s < HALF_PI) {\n      s = Math.sin(lat);\n      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat)); //temp = this.long0 + p.x / (this.a * Math.cos(lat));\n\n      lon = adjust_lon(temp);\n    } else if (s - EPSLN < HALF_PI) {\n      lon = this.long0;\n    }\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\nexport var names = [\"Sinusoidal\", \"sinu\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"sources":["C:/Users/brand/source/repos/DAS-Server/client/node_modules/proj4/lib/projections/sinu.js"],"names":["adjust_lon","adjust_lat","pj_enfn","MAX_ITER","pj_mlfn","pj_inv_mlfn","EPSLN","HALF_PI","asinz","init","sphere","en","es","n","m","C_y","Math","sqrt","C_x","forward","p","x","y","lon","lat","long0","asin","sin","k","i","V","cos","abs","a","s","c","inverse","temp","x0","y0","names"],"mappings":"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","sourcesContent":["import adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\nimport pj_enfn from '../common/pj_enfn';\nvar MAX_ITER = 20;\nimport pj_mlfn from '../common/pj_mlfn';\nimport pj_inv_mlfn from '../common/pj_inv_mlfn';\nimport {EPSLN, HALF_PI} from '../constants/values';\n\nimport asinz from '../common/asinz';\n\n\nexport function init() {\n  /* Place parameters in static storage for common use\n    -------------------------------------------------*/\n\n\n  if (!this.sphere) {\n    this.en = pj_enfn(this.es);\n  }\n  else {\n    this.n = 1;\n    this.m = 0;\n    this.es = 0;\n    this.C_y = Math.sqrt((this.m + 1) / this.n);\n    this.C_x = this.C_y / (this.m + 1);\n  }\n\n}\n\n/* Sinusoidal forward equations--mapping lat,long to x,y\n  -----------------------------------------------------*/\nexport function forward(p) {\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n    -----------------*/\n  lon = adjust_lon(lon - this.long0);\n\n  if (this.sphere) {\n    if (!this.m) {\n      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;\n    }\n    else {\n      var k = this.n * Math.sin(lat);\n      for (var i = MAX_ITER; i; --i) {\n        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));\n        lat -= V;\n        if (Math.abs(V) < EPSLN) {\n          break;\n        }\n      }\n    }\n    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));\n    y = this.a * this.C_y * lat;\n\n  }\n  else {\n\n    var s = Math.sin(lat);\n    var c = Math.cos(lat);\n    y = this.a * pj_mlfn(lat, s, c, this.en);\n    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var lat, temp, lon, s;\n\n  p.x -= this.x0;\n  lon = p.x / this.a;\n  p.y -= this.y0;\n  lat = p.y / this.a;\n\n  if (this.sphere) {\n    lat /= this.C_y;\n    lon = lon / (this.C_x * (this.m + Math.cos(lat)));\n    if (this.m) {\n      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);\n    }\n    else if (this.n !== 1) {\n      lat = asinz(Math.sin(lat) / this.n);\n    }\n    lon = adjust_lon(lon + this.long0);\n    lat = adjust_lat(lat);\n  }\n  else {\n    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);\n    s = Math.abs(lat);\n    if (s < HALF_PI) {\n      s = Math.sin(lat);\n      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));\n      //temp = this.long0 + p.x / (this.a * Math.cos(lat));\n      lon = adjust_lon(temp);\n    }\n    else if ((s - EPSLN) < HALF_PI) {\n      lon = this.long0;\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Sinusoidal\", \"sinu\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n"]},"metadata":{},"sourceType":"module"}
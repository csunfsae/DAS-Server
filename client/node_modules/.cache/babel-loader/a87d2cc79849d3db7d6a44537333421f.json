{"ast":null,"code":"import msfnz from '../common/msfnz';\nimport adjust_lon from '../common/adjust_lon';\nimport tsfnz from '../common/tsfnz';\nimport phi2z from '../common/phi2z';\nimport { FORTPI, R2D, EPSLN, HALF_PI } from '../constants/values';\nexport function init() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n\n  if (!('x0' in this)) {\n    this.x0 = 0;\n  }\n\n  if (!('y0' in this)) {\n    this.y0 = 0;\n  }\n\n  this.e = Math.sqrt(this.es);\n\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    } else {\n      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  } else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      } else {\n        this.k0 = 1;\n      }\n    }\n  }\n}\n/* Mercator forward equations--mapping lat,long to x,y\n  --------------------------------------------------*/\n\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y; // convert to radians\n\n  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n    return null;\n  }\n\n  var x, y;\n\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    return null;\n  } else {\n    if (this.sphere) {\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n    } else {\n      var sinphi = Math.sin(lat);\n      var ts = tsfnz(this.e, lat, sinphi);\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n\n    p.x = x;\n    p.y = y;\n    return p;\n  }\n}\n/* Mercator inverse equations--mapping x,y to lat/long\n  --------------------------------------------------*/\n\nexport function inverse(p) {\n  var x = p.x - this.x0;\n  var y = p.y - this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n  } else {\n    var ts = Math.exp(-y / (this.a * this.k0));\n    lat = phi2z(this.e, ts);\n\n    if (lat === -9999) {\n      return null;\n    }\n  }\n\n  lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\nexport var names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"sources":["C:/Users/brand/source/repos/das-server/client/node_modules/proj4/lib/projections/merc.js"],"names":["msfnz","adjust_lon","tsfnz","phi2z","FORTPI","R2D","EPSLN","HALF_PI","init","con","b","a","es","x0","y0","e","Math","sqrt","lat_ts","sphere","k0","cos","sin","k","forward","p","lon","x","lat","y","abs","long0","log","tan","sinphi","ts","inverse","atan","exp","names"],"mappings":"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","sourcesContent":["import msfnz from '../common/msfnz';\n\nimport adjust_lon from '../common/adjust_lon';\nimport tsfnz from '../common/tsfnz';\nimport phi2z from '../common/phi2z';\nimport {FORTPI, R2D, EPSLN, HALF_PI} from '../constants/values';\nexport function init() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n  if(!('x0' in this)){\n    this.x0 = 0;\n  }\n  if(!('y0' in this)){\n    this.y0 = 0;\n  }\n  this.e = Math.sqrt(this.es);\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    }\n    else {\n      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  }\n  else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      }\n      else {\n        this.k0 = 1;\n      }\n    }\n  }\n}\n\n/* Mercator forward equations--mapping lat,long to x,y\n  --------------------------------------------------*/\n\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  // convert to radians\n  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n    return null;\n  }\n\n  var x, y;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    return null;\n  }\n  else {\n    if (this.sphere) {\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n    }\n    else {\n      var sinphi = Math.sin(lat);\n      var ts = tsfnz(this.e, lat, sinphi);\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n    p.x = x;\n    p.y = y;\n    return p;\n  }\n}\n\n/* Mercator inverse equations--mapping x,y to lat/long\n  --------------------------------------------------*/\nexport function inverse(p) {\n\n  var x = p.x - this.x0;\n  var y = p.y - this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n  }\n  else {\n    var ts = Math.exp(-y / (this.a * this.k0));\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n"]},"metadata":{},"sourceType":"module"}